// TN-056: Publishing Queue Load Test
// k6 load testing script for validating queue performance
//
// Usage:
//   k6 run --vus 50 --duration 5m tests/load/publishing-queue-load-test.js
//   k6 run --stage "0s:0,1m:100,2m:100,3m:0" tests/load/publishing-queue-load-test.js

import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Trend, Counter } from 'k6/metrics';

// Custom metrics
const submitSuccessRate = new Rate('submit_success_rate');
const submitDuration = new Trend('submit_duration');
const queueSize = new Trend('queue_size');
const dlqSize = new Trend('dlq_size');
const jobsCompleted = new Counter('jobs_completed');
const jobsFailed = new Counter('jobs_failed');

// Test configuration
export const options = {
    scenarios: {
        // Scenario 1: Baseline Load (500 RPS, 5 min)
        baseline: {
            executor: 'constant-arrival-rate',
            rate: 500,
            timeUnit: '1s',
            duration: '5m',
            preAllocatedVUs: 50,
            maxVUs: 100,
            startTime: '0s',
            tags: { scenario: 'baseline' },
        },

        // Scenario 2: Spike Load (1000 RPS, 2 min)
        spike: {
            executor: 'constant-arrival-rate',
            rate: 1000,
            timeUnit: '1s',
            duration: '2m',
            preAllocatedVUs: 100,
            maxVUs: 200,
            startTime: '5m',
            tags: { scenario: 'spike' },
        },

        // Scenario 3: Sustained Load (500 RPS, 1 hour)
        sustained: {
            executor: 'constant-arrival-rate',
            rate: 500,
            timeUnit: '1s',
            duration: '1h',
            preAllocatedVUs: 50,
            maxVUs: 100,
            startTime: '7m',
            tags: { scenario: 'sustained' },
        },

        // Scenario 4: Error Injection (300 RPS, 50% failure, 5 min)
        errorInjection: {
            executor: 'constant-arrival-rate',
            rate: 300,
            timeUnit: '1s',
            duration: '5m',
            preAllocatedVUs: 30,
            maxVUs: 50,
            startTime: '1h7m',
            tags: { scenario: 'error_injection' },
            exec: 'submitAlertWithErrors',
        },
    },

    thresholds: {
        // HTTP request duration
        'http_req_duration': ['p(95)<100', 'p(99)<200'],

        // Success rate
        'submit_success_rate': ['rate>0.99'],

        // Submit duration (job creation)
        'submit_duration': ['p(95)<50', 'p(99)<100'],

        // Queue size
        'queue_size': ['avg<1000', 'max<5000'],

        // DLQ size
        'dlq_size': ['avg<50', 'max<100'],

        // HTTP errors
        'http_req_failed': ['rate<0.01'],
    },
};

// Environment configuration
const BASE_URL = __ENV.BASE_URL || 'http://localhost:8080';
const API_TOKEN = __ENV.API_TOKEN || '';

// Alert templates for different priorities
const HIGH_PRIORITY_ALERT = {
    fingerprint: `high-${Date.now()}-${Math.random()}`,
    alert_name: 'CriticalAlert',
    status: 'firing',
    labels: {
        alertname: 'CriticalAlert',
        severity: 'critical',
        priority: 'high',
        environment: 'production',
    },
    annotations: {
        summary: 'Critical alert for load testing',
        description: 'This is a high-priority alert generated by k6 load test',
    },
    starts_at: new Date().toISOString(),
    generator_url: 'http://k6-load-test',
};

const MEDIUM_PRIORITY_ALERT = {
    ...HIGH_PRIORITY_ALERT,
    fingerprint: `medium-${Date.now()}-${Math.random()}`,
    alert_name: 'WarningAlert',
    labels: {
        ...HIGH_PRIORITY_ALERT.labels,
        severity: 'warning',
        priority: 'medium',
    },
};

const LOW_PRIORITY_ALERT = {
    ...HIGH_PRIORITY_ALERT,
    fingerprint: `low-${Date.now()}-${Math.random()}`,
    alert_name: 'InfoAlert',
    labels: {
        ...HIGH_PRIORITY_ALERT.labels,
        severity: 'info',
        priority: 'low',
    },
};

// Get random alert with priority distribution (20% high, 50% medium, 30% low)
function getRandomAlert() {
    const rand = Math.random();
    if (rand < 0.2) {
        return HIGH_PRIORITY_ALERT;
    } else if (rand < 0.7) {
        return MEDIUM_PRIORITY_ALERT;
    } else {
        return LOW_PRIORITY_ALERT;
    }
}

// Main scenario: Submit alert to publishing queue
export default function() {
    const alert = getRandomAlert();

    const headers = {
        'Content-Type': 'application/json',
    };

    if (API_TOKEN) {
        headers['Authorization'] = `Bearer ${API_TOKEN}`;
    }

    const payload = JSON.stringify({
        alert: alert,
        // target_name: '', // Empty = broadcast to all targets
    });

    const startTime = Date.now();
    const response = http.post(
        `${BASE_URL}/api/v1/publishing/submit`,
        payload,
        { headers: headers }
    );
    const duration = Date.now() - startTime;

    // Check response
    const success = check(response, {
        'status is 202': (r) => r.status === 202,
        'response has success': (r) => {
            try {
                const body = JSON.parse(r.body);
                return body.success === true;
            } catch (e) {
                return false;
            }
        },
        'response has job_ids': (r) => {
            try {
                const body = JSON.parse(r.body);
                return Array.isArray(body.job_ids) && body.job_ids.length > 0;
            } catch (e) {
                return false;
            }
        },
    });

    // Record metrics
    submitSuccessRate.add(success);
    submitDuration.add(duration);

    if (success) {
        jobsCompleted.add(1);
    } else {
        jobsFailed.add(1);
    }

    // Fetch queue stats every 10 requests (sampling)
    if (__ITER % 10 === 0) {
        const statsResponse = http.get(
            `${BASE_URL}/api/v1/publishing/queue/stats`,
            { headers: headers }
        );

        if (statsResponse.status === 200) {
            try {
                const stats = JSON.parse(statsResponse.body);
                queueSize.add(stats.total_size || 0);
                dlqSize.add(stats.dlq_size || 0);
            } catch (e) {
                console.error('Failed to parse queue stats:', e);
            }
        }
    }

    // Small delay to avoid overwhelming the system
    sleep(0.01);
}

// Scenario 4: Submit alert with intentional errors (for error injection testing)
export function submitAlertWithErrors() {
    const alert = getRandomAlert();

    // 50% of requests will target a non-existent target (simulate failures)
    const targetName = Math.random() < 0.5 ? 'non-existent-target' : '';

    const headers = {
        'Content-Type': 'application/json',
    };

    if (API_TOKEN) {
        headers['Authorization'] = `Bearer ${API_TOKEN}`;
    }

    const payload = JSON.stringify({
        alert: alert,
        target_name: targetName,
    });

    const response = http.post(
        `${BASE_URL}/api/v1/publishing/submit`,
        payload,
        { headers: headers }
    );

    // For error injection, we expect some failures
    const success = response.status === 202 || response.status === 404;
    submitSuccessRate.add(success);

    sleep(0.01);
}

// Setup: Run once before all VUs start
export function setup() {
    console.log('ðŸš€ Starting TN-056 Publishing Queue Load Test');
    console.log(`   Base URL: ${BASE_URL}`);
    console.log(`   Scenarios: baseline (500 RPS), spike (1000 RPS), sustained (500 RPS), error injection (300 RPS)`);
    console.log(`   Duration: ~1h 12m total`);

    // Health check
    const healthResponse = http.get(`${BASE_URL}/healthz`);
    if (healthResponse.status !== 200) {
        console.error('âŒ Health check failed! Server not ready.');
        throw new Error('Server health check failed');
    }

    console.log('âœ… Health check passed');
    return { startTime: Date.now() };
}

// Teardown: Run once after all VUs finish
export function teardown(data) {
    const duration = (Date.now() - data.startTime) / 1000;
    console.log(`\nðŸ Load test completed in ${duration.toFixed(2)}s`);
    console.log('   Check results with: k6 cloud <run-id> or k6 analyze results.json');
}
