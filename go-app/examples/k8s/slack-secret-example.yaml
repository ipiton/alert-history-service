# Slack Publishing Target - K8s Secret Configuration Example
#
# This example shows how to configure Slack webhook publishing targets
# for alert-history-service through Kubernetes Secrets.
#
# The service auto-discovers publishing targets via label selector:
#   publishing-target: "true"
#
# Features:
# - Slack Webhook API v1 integration
# - Message threading (resolved alerts reply to firing message)
# - Rate limiting (1 message/second)
# - 24h message ID cache (for threading)
# - Prometheus metrics (8 metrics)
# - Retry logic (exponential backoff 100msâ†’5s, max 3 retries)
apiVersion: v1
kind: Secret
metadata:
  name: slack-general-alerts
  namespace: monitoring
  labels:
    publishing-target: "true"  # Required for auto-discovery
    team: "platform"
    environment: "production"
type: Opaque
stringData:
  target.json: |
    {
      "name": "slack-general-alerts",
      "type": "slack",
      "url": "https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXX",
      "enabled": true,
      "format": "slack",
      "headers": {},
      "filter_config": {
        "min_severity": "warning"
      }
    }

---
# Example: Critical alerts only (to #incidents channel)
apiVersion: v1
kind: Secret
metadata:
  name: slack-incidents-critical
  namespace: monitoring
  labels:
    publishing-target: "true"
    team: "sre"
    environment: "production"
type: Opaque
stringData:
  target.json: |
    {
      "name": "slack-incidents-critical",
      "type": "slack",
      "url": "https://hooks.slack.com/services/T00000000/B00000001/YYYYYYYYYYYYYYYYYYYY",
      "enabled": true,
      "format": "slack",
      "headers": {},
      "filter_config": {
        "min_severity": "critical",
        "namespaces": ["production", "staging"]
      }
    }

---
# Example: Team-specific alerts (to #team-backend channel)
apiVersion: v1
kind: Secret
metadata:
  name: slack-team-backend
  namespace: monitoring
  labels:
    publishing-target: "true"
    team: "backend"
    environment: "production"
type: Opaque
stringData:
  target.json: |
    {
      "name": "slack-team-backend",
      "type": "slack",
      "url": "https://hooks.slack.com/services/T00000000/B00000002/ZZZZZZZZZZZZZZZZZZZZ",
      "enabled": true,
      "format": "slack",
      "headers": {},
      "filter_config": {
        "labels": {
          "team": "backend"
        }
      }
    }

---
# Example: Disabled Slack target (for testing)
apiVersion: v1
kind: Secret
metadata:
  name: slack-dev-testing
  namespace: monitoring
  labels:
    publishing-target: "true"
    team: "dev"
    environment: "development"
type: Opaque
stringData:
  target.json: |
    {
      "name": "slack-dev-testing",
      "type": "slack",
      "url": "https://hooks.slack.com/services/T00000000/B00000003/AAAAAAAAAAAAAAAAAAA",
      "enabled": false,
      "format": "slack",
      "headers": {},
      "filter_config": {
        "min_severity": "info"
      }
    }

---
# USAGE INSTRUCTIONS:
#
# 1. Get your Slack webhook URL:
#    - Go to https://api.slack.com/apps
#    - Create new app â†’ "Incoming Webhooks" â†’ "Add New Webhook to Workspace"
#    - Copy webhook URL (https://hooks.slack.com/services/...)
#
# 2. Create Secret:
#    kubectl create -f slack-secret-example.yaml
#
# 3. Verify auto-discovery:
#    kubectl get secrets -n monitoring -l publishing-target=true
#
# 4. Check alert-history-service logs:
#    kubectl logs -n monitoring deployment/alert-history-service | grep "Discovered target"
#
# 5. Test alert publishing:
#    curl -X POST http://alert-history-service:8080/api/v2/alerts \
#      -H "Content-Type: application/json" \
#      -d '{"alerts": [{"labels": {"alertname": "TestAlert", "severity": "critical"}, "status": "firing"}]}'
#
# SLACK MESSAGE FORMAT:
#
# Slack messages use Block Kit format with:
# - Header block: Alert name + status emoji
# - Section block: Alert details (status, namespace, AI severity)
# - Section block: AI reasoning (truncated to 300 chars)
# - Section block: Recommendations (up to 3)
# - Attachments: Color-coded by severity (red/orange/green/gray)
#
# MESSAGE THREADING:
#
# - Firing alert â†’ New message posted â†’ Message timestamp cached (24h)
# - Resolved alert â†’ Reply in thread to original firing message
# - Still firing (repeat) â†’ Reply in thread with "ðŸ”´ Still firing" status
# - Cache miss on resolved â†’ New message posted (with warning log)
#
# FILTER CONFIGURATION:
#
# Supported filters:
# - min_severity: "info" | "warning" | "critical" | "noise"
# - namespaces: ["namespace1", "namespace2", ...]
# - labels: {"key": "value", ...}
#
# PROMETHEUS METRICS:
#
# - alert_history_publishing_slack_messages_posted_total (by status)
# - alert_history_publishing_slack_thread_replies_total
# - alert_history_publishing_slack_message_errors_total (by error_type)
# - alert_history_publishing_slack_api_request_duration_seconds (by method, status)
# - alert_history_publishing_slack_cache_hits_total
# - alert_history_publishing_slack_cache_misses_total
# - alert_history_publishing_slack_cache_size
# - alert_history_publishing_slack_rate_limit_hits_total
#
# ERROR HANDLING:
#
# Retryable errors (exponential backoff):
# - 429 Too Many Requests (rate limit)
# - 503 Service Unavailable (Slack API down)
# - Network timeouts/connection errors
#
# Non-retryable errors (fail fast):
# - 400 Bad Request (invalid payload)
# - 403 Forbidden (invalid webhook URL)
# - 404 Not Found (webhook deleted)
# - 500 Internal Server Error (Slack bug)
#
# RATE LIMITING:
#
# - Slack limit: 1 message per second per webhook URL
# - Implemented: Token bucket (1 msg/sec, burst 1)
# - Exceeded: 429 error, retry after backoff
#
# SECURITY NOTES:
#
# - Webhook URL is sensitive (grants write access to Slack channel)
# - Store in Kubernetes Secret (not ConfigMap)
# - Use RBAC to restrict Secret access
# - Rotate webhooks periodically (create new, delete old)
# - Monitor alert_history_publishing_slack_message_errors_total for unauthorized access
